# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RSDesigner
                                 A QGIS plugin
 This plugin designs a rainwater drainage network.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-17
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Zhiyu Zhang
        email                : 2032846@tongji.edu.cn
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

'''
TODO Problems
1. 简化功能点为平面布局设计、水力设计计算、模型评估，再加一个一步到位的设计功能
2. 水力设计计算校核计算结果，输出水力计算表，并且能对手动设计的布局进行计算
3. 模型评估保证一个短历时一个长历时降雨的评估，输出报告中的指标，加上模型运行时长。
4. 尝试添加报错信息

'''

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication,pyqtSignal,QObject
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QFileDialog,QTableWidgetItem
from qgis.core import Qgis,QgsProject,QgsVectorLayer

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .rs_one_dialog import RSOneDialog
from .rs_layout_dialog import RSLayoutDialog
from .rs_hydraul_dialog import RSHydraulDialog
from .rs_config_dialog import RSConfigDialog
from .rs_dem_dialog import RSDemDialog
from .rs_node_dialog import RSNodeDialog
from .rs_line_dialog import RSLineDialog
from .rs_subcatch_dialog import RSSubcatchDialog
from .rs_river_dialog import RSRiverDialog
from .rs_simulate_dialog import RSSimulateDialog
from .rs_rain_dialog import RSRainDialog
from .rs_process_dialog import RSProcessDialog

import os.path
from os import getcwd,chdir
import geopandas as gpd
from pyswmm import Simulation
from threading import Thread

from .RS_toolkit import read_resample,create_subcatch,update_area,create_out,DEMGenerate,\
    formulate,break_pipes,break_cycle,export_net,configurate,update_graph,merge_outfall_area,\
    get_elevation,export_hydraulic_table,check_field,read_pipes,find_node
from .SWMM_writer2 import create_model,Chicago_icm,insert_rainfall
from .SWMM_eval import get_simulate_file,get_inp,eval_rpt,eval_quanti


class SignalStore(QObject):
    progress_update1 = pyqtSignal(int)
    progress_update2 = pyqtSignal(int)
so = SignalStore()


class RSDesigner:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RSDesigner_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Rainwater System Designer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RSDesigner', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.actions = []

        self.icon_path = os.path.join(os.path.dirname(__file__),'icons/%s.png')
        self.direct_design = QAction(QIcon(self.icon_path%'One'),
                                self.tr(u'Layout and Hydraulic Design'),
                                self.iface.mainWindow())
        self.direct_design.triggered.connect(self.one)
        self.iface.addPluginToMenu(self.menu, self.direct_design)
        self.actions.append(self.direct_design)
        # self.direct_design.first_start = True        
        
        
        self.create_layout = QAction(QIcon(self.icon_path%'Layout'),
                                self.tr(u'Layout Design'),
                                self.iface.mainWindow())
        self.create_layout.triggered.connect(self.layout)
        self.iface.addPluginToMenu(self.menu, self.create_layout)
        self.actions.append(self.create_layout)
        # self.create_layout.first_start = True
        # self.add_action(
        #     icon_path%'Resample',
        #     text=self.tr(u'Resample'),
        #     callback=self.run,
        #     parent=self.iface.mainWindow())

        # will be set False in run()
        

        self.create_hydraul = QAction(QIcon(self.icon_path%'Hydraul'),
                                       self.tr(u'Hydraulic Design'),
                                       self.iface.mainWindow())
        self.create_hydraul.triggered.connect(self.Hydraul)
        self.iface.addPluginToMenu(self.menu, self.create_hydraul)
        self.actions.append(self.create_hydraul)
        # self.create_hydraul.first_start = True
        # self.add_action(
        #     icon_path%'Subcatch',
        #     text=self.tr(u'Create Subcatchments'),
        #     callback=self.run,
        #     parent=self.iface.mainWindow())
                     
        self.eval_simulate = QAction(QIcon(self.icon_path%'Simulate'),
                                       self.tr(u'Model Simulation'),
                                       self.iface.mainWindow())
        self.eval_simulate.triggered.connect(self.Simulate)
        self.iface.addPluginToMenu(self.menu, self.eval_simulate)
        self.actions.append(self.eval_simulate)
        # self.eval_simulate.first_start = True

        
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Rainwater System Designer'),
                action)
            self.iface.removeToolBarIcon(action)
        
    def select_node(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.shp")
        if os.path.isfile(filename):
            if self.dlg.combonode.findText(filename) == -1:
                self.dlg.combonode.addItem(filename)
            self.dlg.combonode.setCurrentText(filename)
            
 
    def check_changed(self):
        if self.dlg.checkBox.isChecked():
            self.dlg.combonode.setEnabled(False)
            self.dlg.inputButton.setEnabled(False)
            self.dlg.inputButton_2.setEnabled(False)
            self.dlg.inputButton2_2.setEnabled(False)
            self.dlg.inputButton5_2.setEnabled(False)
            self.dlg.comboriver.setEnabled(True)
            self.dlg.inputButton6.setEnabled(True)
            self.dlg.inputButton6_2.setEnabled(True)
        else:
            self.dlg.combonode.setEnabled(True)
            self.dlg.inputButton.setEnabled(True)
            self.dlg.inputButton_2.setEnabled(True)
            self.dlg.inputButton2_2.setEnabled(True)
            self.dlg.inputButton5_2.setEnabled(True)
            self.dlg.comboriver.setEnabled(False)
            self.dlg.inputButton6.setEnabled(False)
            self.dlg.inputButton6_2.setEnabled(False)            
        
        
        
    def select_line(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.shp")
        if os.path.isfile(filename):
            if self.dlg.comboline.findText(filename) == -1:
                self.dlg.comboline.addItem(filename)
            self.dlg.comboline.setCurrentText(filename)
        
    def select_river(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.shp")
        if os.path.isfile(filename):
            if self.dlg.comboriver.findText(filename) == -1:
                self.dlg.comboriver.addItem(filename)
            self.dlg.comboriver.setCurrentText(filename)
        
    def river_changed(self):
        self.dlg7 = RSRiverDialog()
        if self.dlg.combodem.currentText() != None:
            self.riverfield = [self.dlg7.checkBox.isChecked(),
                               eval(self.dlg7.disEdit.text().strip()),
                               eval(self.dlg7.disEdit2.text().strip())] 
            
    def select_riverfield(self):
        self.dlg7.show()
        result = self.dlg7.exec_()
        if result:
            self.riverfield = [self.dlg7.checkBox.isChecked(),
                               eval(self.dlg7.disEdit.text().strip()),
                               eval(self.dlg7.disEdit2.text().strip())]
            pass
        
        
    def select_road(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.shp")
        if os.path.isfile(filename):
            if self.dlg.comboroad.findText(filename) == -1:
                self.dlg.comboroad.addItem(filename)
            self.dlg.comboroad.setCurrentText(filename)    
        
    def select_region(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.shp")
        if os.path.isfile(filename):
            if self.dlg.comboregion.findText(filename) == -1:
                self.dlg.comboregion.addItem(filename)
            self.dlg.comboregion.setCurrentText(filename)    
        
    def select_config(self):
        self.dlg2 = RSConfigDialog()
        # pic_size = self.dlg2.StormLabel.geometry()
        # pix = QPixmap(self.icon_path%'StormDesign').scaled(pic_size.width()-5,
        #                                                    pic_size.height()-5)
        # self.dlg2.StormLabel.setPixmap(pix)
        self.dlg2.show()
        result = self.dlg2.exec_()
        if result:
            cons = [getattr(self.dlg2,'lineEdit_%s'%i).text().strip()
                    for i in range(1,11)]
            flow = [self.dlg2.tableWidget.item(i,0).text()
                    for i in range(self.dlg2.tableWidget.rowCount())
                    if self.dlg2.tableWidget.item(i,0) is not None]
            flow = ','.join([f.strip() for f in flow if f.strip()!= ''])
            diam = [self.dlg2.tableWidget.item(i,1).text()
                    for i in range(self.dlg2.tableWidget.rowCount())
                    if self.dlg2.tableWidget.item(i,0) is not None]
            diam = ','.join([f.strip() for f in diam if f.strip()!= ''])
            cons += [flow,diam]
            text = '''"t0={0}";"P={1}";"A={2}";"c={3}";"b={4}";"n={5}";"phi={6}";"n0={7}";"futu={8}";"outlevel={9}";"flow={10}";"diam={11}"'''.format(*cons)            
            self.dlg.configEdit.setText(text)
            pass
        
    
    def select_option(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select input file","","*.json")
        self.dlg.optionEdit.setText(filename)
        
    def select_dem(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select dem file","","*.tif *.shp *.csv")
        if os.path.isfile(filename):
            if self.dlg.combodem.findText(filename) == -1:
                self.dlg.combodem.addItem(filename)
            self.dlg.combodem.setCurrentText(filename)  

    def dem_changed(self):
        self.dlg3 = RSDemDialog()
        self.dlg3.comboBox.setEnabled(False)
        self.dlg3.comboBox2.setEnabled(False)
        self.dlg3.comboBox3.setEnabled(False)
        self.dlg3.comboBox.clear()
        self.dlg3.comboBox2.clear()
        self.dlg3.comboBox3.clear()        
        if self.dlg.combodem.currentText() != None:
            dem_file = self.dlg.combodem.currentText()\
                if os.path.isfile(self.dlg.combodem.currentText()) else\
                    self.layers[self.dlg.combodem.currentIndex()].source()   
            if dem_file.endswith('shp'):
                columns = list(gpd.read_file(dem_file).columns)
                self.dlg3.comboBox3.setEnabled(True)
                self.dlg3.comboBox3.addItems(columns)    
                pot = {'Z','z','Z_VALUE','VALUE'}.intersection(set(columns))
                if pot != set():
                    self.dlg3.comboBox3.setCurrentText(list(pot)[0])
            elif dem_file.endswith('csv'):
                columns = list(gpd.pd.read_csv(dem_file).columns)
                self.dlg3.comboBox.setEnabled(True)
                self.dlg3.comboBox2.setEnabled(True)
                self.dlg3.comboBox3.setEnabled(True)
                self.dlg3.comboBox.addItems(columns)
                self.dlg3.comboBox2.addItems(columns)
                self.dlg3.comboBox3.addItems(columns)                
                pot = {'X','x','lng','LNG'}.intersection(set(columns))
                if pot != set():
                    self.dlg3.comboBox.setCurrentText(list(pot)[0])       
                pot = {'Y','y','lat','LAT'}.intersection(set(columns))
                if pot != set():
                    self.dlg3.comboBox2.setCurrentText(list(pot)[0])                           
                pot = {'Z','VALUE','Z_VALUE'}.intersection(set(columns))
                if pot != set():
                    self.dlg3.comboBox3.setCurrentText(list(pot)[0])      
            self.demfield = [self.dlg3.comboBox.currentText(),
                             self.dlg3.comboBox2.currentText(),
                             self.dlg3.comboBox3.currentText()]
        
    def select_demfield(self):
        if self.dlg.combodem.currentText() != None:         
            self.dlg3.show()
            result = self.dlg3.exec_()
            if result:
                self.demfield = [self.dlg3.comboBox.currentText(),
                                 self.dlg3.comboBox2.currentText(),
                                 self.dlg3.comboBox3.currentText()]
                pass
            

    def node_changed(self):
        self.dlg4 = RSNodeDialog()
        self.dlg4.comboBox.setEnabled(False)
        self.dlg4.comboBox2.setEnabled(False)
        self.dlg4.comboBox3.setEnabled(False)
        self.dlg4.comboBox.clear()
        self.dlg4.comboBox2.clear()
        self.dlg4.comboBox3.clear()        
        if self.dlg.combonode.currentText() != None:
            node_file = self.dlg.combonode.currentText()\
                if os.path.isfile(self.dlg.combonode.currentText()) else\
                    self.layers[self.dlg.combonode.currentIndex()].source()   
            if node_file.endswith('shp'):
                columns = list(gpd.read_file(node_file).columns)
                self.dlg4.comboBox.setEnabled(True)
                self.dlg4.comboBox2.setEnabled(True)
                self.dlg4.comboBox3.setEnabled(True)
                self.dlg4.comboBox.addItems(columns)
                self.dlg4.comboBox2.addItems(columns)
                self.dlg4.comboBox3.addItems(columns)
                pot = {'name','Name','NAME','node','Node'}.intersection(set(columns))
                if pot != set():
                    self.dlg4.comboBox.setCurrentText(list(pot)[0])                       
                pot = {'node_type','type','TYPE'}.intersection(set(columns))
                if pot != set():
                    self.dlg4.comboBox2.setCurrentText(list(pot)[0])
                pot = {'lo_area','area','AREA'}.intersection(set(columns))
                if pot != set():
                    self.dlg4.comboBox3.setCurrentText(list(pot)[0])
                self.nodefield = [self.dlg4.comboBox.currentText(),
                                 self.dlg4.comboBox2.currentText(),
                                 self.dlg4.comboBox3.currentText()]
                
    def select_nodefield(self):
        if self.dlg.combonode.currentText() != None:         
            self.dlg4.show()
            result = self.dlg4.exec_()
            if result:
                self.nodefield = [self.dlg4.comboBox.currentText(),
                                 self.dlg4.comboBox2.currentText(),
                                 self.dlg4.comboBox3.currentText()]
                pass        
                
    def line_changed(self):
        self.dlg5 = RSLineDialog()
        self.dlg5.comboBox.setEnabled(False)
        self.dlg5.comboBox2.setEnabled(False)
        self.dlg5.comboBox3.setEnabled(False)
        self.dlg5.comboBox.clear()
        self.dlg5.comboBox2.clear()
        self.dlg5.comboBox3.clear()        
        if self.dlg.comboline.currentText() != None:
            line_file = self.dlg.comboline.currentText()\
                if os.path.isfile(self.dlg.comboline.currentText()) else\
                    self.layers[self.dlg.comboline.currentIndex()].source()   
            if line_file.endswith('shp'):
                columns = list(gpd.read_file(line_file).columns)
                columns.remove('geometry')
                columns.append('geometry.length')
                self.dlg5.comboBox.setEnabled(True)
                self.dlg5.comboBox2.setEnabled(True)
                self.dlg5.comboBox3.setEnabled(True)
                self.dlg5.comboBox.addItems(columns)
                self.dlg5.comboBox2.addItems(columns)
                self.dlg5.comboBox3.addItems(columns)
                pot = {'us_node','source','start'}.intersection(set(columns))
                if pot != set():
                    self.dlg5.comboBox.setCurrentText(list(pot)[0])                       
                pot = {'ds_node','target','end'}.intersection(set(columns))
                if pot != set():
                    self.dlg5.comboBox2.setCurrentText(list(pot)[0])
                pot = {'length','Length'}.intersection(set(columns))
                if pot != set():
                    self.dlg5.comboBox3.setCurrentText(list(pot)[0])
                self.linefield = [self.dlg5.comboBox.currentText(),
                                 self.dlg5.comboBox2.currentText(),
                                 self.dlg5.comboBox3.currentText()]
                
    def select_linefield(self):
        if self.dlg.comboline.currentText() != None:         
            self.dlg5.show()
            result = self.dlg5.exec_()
            if result:
                self.linefield = [self.dlg5.comboBox.currentText(),
                                 self.dlg5.comboBox2.currentText(),
                                 self.dlg5.comboBox3.currentText()]
                pass                    
            

    def region_changed(self):
        self.dlg6 = RSSubcatchDialog()
        self.dlg6.comboBox.setEnabled(False)
        self.dlg6.comboBox2.setEnabled(False)
        self.dlg6.comboBox3.setEnabled(False)
        self.dlg6.comboBox.clear()
        self.dlg6.comboBox2.clear()
        self.dlg6.comboBox3.clear()        
        if self.dlg.comboregion.currentText() != None:
            region_file = self.dlg.comboregion.currentText()\
                if os.path.isfile(self.dlg.comboregion.currentText()) else\
                    self.layers[self.dlg.comboregion.currentIndex()].source()   
            if region_file.endswith('shp'):
                columns = list(gpd.read_file(region_file).columns)
                columns.remove('geometry')
                columns.append('geometry.area')
                self.dlg6.comboBox.setEnabled(True)
                self.dlg6.comboBox2.setEnabled(True)
                self.dlg6.comboBox3.setEnabled(True)
                self.dlg6.comboBox.addItems(columns)
                self.dlg6.comboBox2.addItems(columns)
                self.dlg6.comboBox3.addItems(columns)
                pot = {'id','name','ID','NAME'}.intersection(set(columns))
                if pot != set():
                    self.dlg6.comboBox.setCurrentText(list(pot)[0])                       
                pot = {'node','NODE'}.intersection(set(columns))
                if pot != set():
                    self.dlg6.comboBox2.setCurrentText(list(pot)[0])
                pot = {'area','lo_area','AREA'}.intersection(set(columns))
                if pot != set():
                    self.dlg6.comboBox3.setCurrentText(list(pot)[0])
                self.regionfield = [self.dlg6.comboBox.currentText(),
                                 self.dlg6.comboBox2.currentText(),
                                 self.dlg6.comboBox3.currentText()]
                
    def select_regionfield(self):
        if self.dlg.comboregion.currentText() != None:         
            self.dlg6.show()
            result = self.dlg6.exec_()
            if result:
                self.regionfield = [self.dlg6.comboBox.currentText(),
                                 self.dlg6.comboBox2.currentText(),
                                 self.dlg6.comboBox3.currentText()]
                pass   
                             
    def inp_changed(self):
        filename = self.dlg.lineEdit.text()
        if os.path.isfile(filename):
            self.dlg.rainButton.setEnabled(True)
            if self.dlg.checkBox.isChecked():
                self.dlg.rainButton_2.setEnabled(True)
            else:
                self.dlg.rainButton_2.setEnabled(False)
                
            inp = get_inp(filename)
            self.rainfield = {}
            for k,v in inp['TIMESERIES'].items():
                ts = v.data
                interval = ts[1][0] - ts[0][0]
                dura = (ts[-1][0]-ts[0][0]+interval)*60
                interval = '{0}:{1}'.format(str(int(interval)).zfill(2),str(int((interval-int(interval))*60)).zfill(2))
                if 'CURVES' in inp and k in inp['CURVES']:
                    is_tidal = True
                else:
                    is_tidal = False
                self.rainfield[k] = {'type':inp.RAINGAGES['RG'].Format,
                                     'interval':interval,
                                     'duration':dura,
                                     'is_tidal':is_tidal}            
            self.inp = inp
            self.dlg.comboBox.clear()
            self.dlg.comboBox.addItems(list(inp['TIMESERIES'].keys()))
            self.dlg.comboBox_2.clear()
            self.dlg.comboBox_2.addItems(list(inp['TIMESERIES'].keys()))            
        else:
            self.dlg.rainButton.setEnabled(False)
            self.dlg.rainButton_2.setEnabled(False)
            self.dlg.comboBox.clear()
            self.dlg.comboBox_2.clear()
            
            
    def select_inp(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg,"Select SWMM file","","*.inp")
        self.dlg.lineEdit.setText(filename)

        
        
    def type_changed(self):
        if self.dlg2.comboBox.currentText() == '降雨量占比 (%)':
            self.dlg2.precipEdit.setEnabled(True)
        else:
            self.dlg2.precipEdit.setEnabled(False)
        self.dlg2.tableWidget.setHorizontalHeaderItem(1,QTableWidgetItem(self.dlg2.comboBox.currentText()))
        
        
    def select_rain(self):
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg2,"Select rainfall file","","*.csv")
        if os.path.isfile(filename):
            rain = gpd.pd.read_csv(filename)
            self.dlg2.tableWidget.clearContents()
            for idx,time,data in zip(rain.index,rain[rain.columns[0]],rain[rain.columns[1]]):
                self.dlg2.tableWidget.setItem(idx,0,QTableWidgetItem(str(time)))
                self.dlg2.tableWidget.setItem(idx,1,QTableWidgetItem(str(round(data,3))))
            if len(rain.columns)>2:
                for idx,level in zip(rain.index,rain[rain.columns[2]]):
                    self.dlg2.tableWidget.setItem(idx,2,QTableWidgetItem(str(level)))
        
    def insert_chicago(self):
        paras = tuple([getattr(self.dlg2,'%sEdit'%co).text().strip()
                for co in ['a','c','n','b','interval','dura','r','p']])
        para = [eval(pa) for pa in paras if ':' not in pa]
        para += [int(pa.split(':')[0])*60+int(pa.split(':')[1])
                for pa in paras if ':' in pa]
        ts = Chicago_icm(para)
        self.dlg2.tableWidget.clearContents()
        for idx,(time,data) in enumerate(ts):
            self.dlg2.tableWidget.setItem(idx,0,QTableWidgetItem(str(time)))
            self.dlg2.tableWidget.setItem(idx,1,QTableWidgetItem(str(round(data,3))))
        self.dlg2.comboBox.setCurrentIndex(3)
            
    def ini_raininfo(self,name):
        self.dlg2.nameEdit.setText(name)
        if self.rainfield[name]['type'] == 'VOLUME':
            self.dlg2.comboBox.setCurrentIndex(1)
        elif self.rainfield[name]['type'] == 'CUMULATIVE':
            self.dlg2.comboBox.setCurrentIndex(2)
        elif self.rainfield[name]['type'] == 'INTENSITY':
            self.dlg2.comboBox.setCurrentIndex(3)
        self.dlg2.intervalEdit.setText(self.rainfield[name]['interval'])
        dura = self.rainfield[name]['duration']
        dura = str(int(dura//60)).zfill(2) + ':' + str(int(dura%60)).zfill(2)
        self.dlg2.duraEdit.setText(dura)
        
        self.dlg2.tableWidget.clearContents()
        tss = self.inp['TIMESERIES'][name].data
        for idx,(t,v) in enumerate(tss):
            t = str(int(t)).zfill(2)+':'+str(int(round((t-int(t))*60,0))).zfill(2)
            self.dlg2.tableWidget.setItem(idx,0,QTableWidgetItem(t))
            self.dlg2.tableWidget.setItem(idx,1,QTableWidgetItem(str(round(float(v),3))))
        if self.rainfield[name]['is_tidal']:
            for idx,(_,v) in enumerate(self.inp['CURVES'][name].points):
                self.dlg2.tableWidget.setItem(idx,2,QTableWidgetItem(str(v)))
                    
    def update_rain(self):
        name = self.dlg2.nameEdit.text().strip()
        typ = self.dlg2.comboBox.currentText()
        delta,dura = self.dlg2.intervalEdit.text().strip(),self.dlg2.duraEdit.text().strip()
        dura = int(dura.split(':')[0])*60+int(dura.split(':')[1])
        times = [self.dlg2.tableWidget.item(i,0).text().strip()
                 for i in range(self.dlg2.tableWidget.rowCount())]
        data = [self.dlg2.tableWidget.item(i,1).text().strip()
                 for i in range(self.dlg2.tableWidget.rowCount())]   
        if typ == '降雨量占比 (%)':
            precip = eval(self.dlg2.precipEdit.text().strip())
            data = [str(precip*eval(da)*0.01) for da in data]
            typee = 'VOLUME'
        elif typ == '降雨量 (mm)':
            typee = 'VOLUME'
        elif typ == '累积降雨量 (mm)':
            typee = 'CUMULATIVE'
        else:
            typee = 'INTENSITY'
        tss = [[times[i],data[i]] for i in range(len(data))]
        
        level = [self.dlg2.tableWidget.item(i,2)
                 for i in range(self.dlg2.tableWidget.rowCount())]
        level = [[int(times[idx].split(':')[0])+int(times[idx].split(':')[1])/60,
                  eval(lev.text().strip())]
                 for idx,lev in enumerate(level) if lev is not None]
        
        self.inp = insert_rainfall(self.inp, name, tss, level)
        is_tidal = True if level != [] else False
        self.rainfield[name] = {'type':typee,'interval':delta,
                                'duration':dura,'is_tidal':is_tidal}
        if self.dlg.comboBox.findText(name) == -1:
            self.dlg.comboBox.addItem(name)
        if self.dlg.comboBox_2.findText(name) == -1:
            self.dlg.comboBox_2.addItem(name)     
        return name
            
    def set_rainfall(self):        
        if self.dlg.comboBox.currentText()!='':
            name = self.dlg.comboBox.currentText()
            self.ini_raininfo(name)
        self.dlg2.show()
        result = self.dlg2.exec_()
        if result:
            name = self.update_rain()
            self.dlg.comboBox.setCurrentText(name)
            self.dlg.typeBox.setCurrentText(self.rainfield[name]['type'])
            pass
        
    def set_rainfall2(self):        
        if self.dlg.comboBox_2.currentText()!='':
            name = self.dlg.comboBox_2.currentText()
            self.ini_raininfo(name)
        self.dlg2.show()
        result = self.dlg2.exec_()
        if result:
            name = self.update_rain()
            self.dlg.comboBox_2.setCurrentText(name)
            self.dlg.typeBox_2.setCurrentText(self.rainfield[name]['type'])
            pass        
        
    
    def rain_changed(self):
        if self.dlg.comboBox.currentText() != '':
            self.dlg.typeBox.setCurrentText(self.rainfield[self.dlg.comboBox.currentText()]['type'])
        if self.dlg.comboBox_2.currentText() != '':
            self.dlg.typeBox_2.setCurrentText(self.rainfield[self.dlg.comboBox_2.currentText()]['type'])

    def enable_rain2(self):
        if self.dlg.checkBox.isChecked():
            self.dlg.comboBox_2.setEnabled(True)
            self.dlg.typeBox_2.setEnabled(True)
            self.dlg.coeEdit_2.setEnabled(True)
            if self.dlg.rainButton.isEnabled():
                self.dlg.rainButton_2.setEnabled(True)
        else:
            self.dlg.comboBox_2.setEnabled(False)
            self.dlg.typeBox_2.setEnabled(False)
            self.dlg.coeEdit_2.setEnabled(False)        
            self.dlg.rainButton_2.setEnabled(False)
        
    def output_dir(self):
        filedir = QFileDialog.getExistingDirectory(
            self.dlg,"Select output path")
        self.dlg.outdirEdit.setText(filedir)        
        
    def output_csv(self):
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg,"Select output file","","*.csv")
        self.dlg.outdirEdit.setText(filename)
        

            
    def one(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.direct_design.first_start == True:
            # self.direct_design.first_start = False
        self.dlg = RSOneDialog()
        self.dlg.inputButton.clicked.connect(self.select_line)
        self.dlg.inputButton2.clicked.connect(self.select_river)
        self.dlg.inputButton3.clicked.connect(self.select_road)
        self.dlg.inputButton4.clicked.connect(self.select_region)
        self.dlg.fieldButton.clicked.connect(self.select_config)
        self.dlg.inputButton5.clicked.connect(self.select_dem)
        self.dlg.inputButton5_2.clicked.connect(self.select_demfield)            
        self.dlg.outputButton.clicked.connect(self.output_dir)   
        self.dlg.combodem.currentTextChanged.connect(self.dem_changed)
        
        
        layers = list(QgsProject.instance().mapLayers().values())
        self.layers = layers
        layer_names = [l.name() for l in layers]
        self.dlg.comboline.clear()
        self.dlg.comboriver.clear()
        self.dlg.comboroad.clear()
        self.dlg.comboregion.clear()
        self.dlg.combodem.clear()

        self.dlg.comboline.addItems(layer_names)
        self.dlg.comboriver.addItems(layer_names)
        self.dlg.comboroad.addItems(layer_names)
        self.dlg.comboregion.addItems(layer_names)           
        self.dlg.combodem.addItems(layer_names)
        
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pipe_file = self.dlg.comboline.currentText()\
                if os.path.isfile(self.dlg.comboline.currentText()) else\
                    layers[self.dlg.comboline.currentIndex()].source()
                
            river_file = self.dlg.comboriver.currentText()\
                if os.path.isfile(self.dlg.comboriver.currentText()) else\
                    layers[self.dlg.comboriver.currentIndex()].source()

            road_file = self.dlg.comboroad.currentText()\
                if os.path.isfile(self.dlg.comboroad.currentText()) else\
                    layers[self.dlg.comboroad.currentIndex()].source()
                    
            region_file = self.dlg.comboregion.currentText()\
                if os.path.isfile(self.dlg.comboregion.currentText()) else\
                    layers[self.dlg.comboregion.currentIndex()].source()
                    
            dis = self.dlg.disEdit.text()
            dis = None if dis == '' else eval(dis)
            
            outdis = self.dlg.disEdit2.text()
            outdis = None if outdis == '' else eval(outdis)
            
            # river_file = None if river_file == '' else river_file
            # region_file = None if region_file == '' else region_file
            if self.dlg.checkBox.isChecked():  
                has_river = True
            else:
                has_river = False
                
            outdir = self.dlg.outdirEdit.text()
            if os.path.isdir(outdir) ==False:
                self.iface.messageBar().pushMessage("出错", "输出路径格式错误",
                                                level=Qgis.Critical, duration=3)                
                
            pipes = gpd.read_file(pipe_file,encoding='gbk')
            river = gpd.read_file(river_file,encoding='gbk')
            road = gpd.read_file(road_file,encoding='gbk') 
            region = gpd.read_file(region_file,encoding='gbk') if region_file is not None else None
            
            nodes,pipes = read_resample(pipes,river,dis)
            Polygons,riverpoly,riverpoints = create_subcatch(nodes,pipes,road,river,
                                                 region,has_river)
            nodes = update_area(nodes,Polygons)        
            nodes,pipes = create_out(nodes,pipes,river,outdis)
            X = formulate(nodes,pipes)
            X,outfalls = break_pipes(X)
            X = break_cycle(X, outfalls)
            nodes,pipes = export_net(X)            
            Polygons,Area = merge_outfall_area(X,Polygons)    
            
  
            config_text = self.dlg.configEdit.text()

            dem_file = self.dlg.combodem.currentText()\
                if os.path.isfile(self.dlg.combodem.currentText()) else\
                    layers[self.dlg.combodem.currentIndex()].source()     
                         
            config = configurate(config_text)
            if dem_file.endswith('.tif') == False:
                dem_file = DEMGenerate(dem_file,self.demfield)                    
            
            X = formulate(nodes,pipes)

            X = get_elevation(X,dem_file)
            DX = update_graph(X,config)
                
            nodes,pipes = export_net(DX)
            table = export_hydraulic_table(DX)
            table.to_excel(os.path.join(outdir,'水力计算表.xlsx'),encoding='gbk')
            quanti = eval_quanti(pipes,'diameter')
            quanti.to_excel(os.path.join(outdir,'工程量统计.xlsx'),encoding='gbk')
            
            create_model(nodes,pipes,Polygons,os.path.join(outdir,'model.inp')) 
            
            Area.to_file(os.path.join(outdir,'subsystem.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'subsystem.shp'),'subsystem',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'subsystem')    

            riverpoly.to_file(os.path.join(outdir,'riverpoly.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'riverpoly.shp'),'riverpoly',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'riverpoly')    
                
            Polygons.to_file(os.path.join(outdir,'subcatch.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'subcatch.shp'),'subcatch',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'subcatch')
                
            pipes.to_file(os.path.join(outdir,'pipes.shp'))            
            vlayer = QgsVectorLayer(os.path.join(outdir,'pipes.shp'),'pipes',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'pipes')                
                
            nodes.to_file(os.path.join(outdir,'nodes.shp'))            
            vlayer = QgsVectorLayer(os.path.join(outdir,'nodes.shp'),'nodes',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'nodes')   
                          
            # nx.write_gpickle(X,outdir)
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            self.iface.messageBar().pushMessage("成功", "平面布局及水力设计",
                                                level=Qgis.Success, duration=3)

            
        
    def layout(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.create_layout.first_start == True:
        # self.create_layout.first_start = False
        self.dlg = RSLayoutDialog()
        self.dlg.inputButton.clicked.connect(self.select_line)
        self.dlg.inputButton2.clicked.connect(self.select_river)
        self.dlg.inputButton3.clicked.connect(self.select_road)
        self.dlg.inputButton4.clicked.connect(self.select_region)
        self.dlg.outputButton.clicked.connect(self.output_dir)

        layers = list(QgsProject.instance().mapLayers().values())
        layer_names = [l.name() for l in layers]
        self.dlg.comboline.clear()
        self.dlg.comboriver.clear()
        self.dlg.comboroad.clear()
        self.dlg.comboregion.clear()

        self.dlg.comboline.addItems(layer_names)
        self.dlg.comboriver.addItems(layer_names)
        self.dlg.comboroad.addItems(layer_names)
        self.dlg.comboregion.addItems(layer_names)    
        # TODO If icons can be found, they should be added
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pipe_file = self.dlg.comboline.currentText()\
                if os.path.isfile(self.dlg.comboline.currentText()) else\
                    layers[self.dlg.comboline.currentIndex()].source()
                
            river_file = self.dlg.comboriver.currentText()\
                if os.path.isfile(self.dlg.comboriver.currentText()) else\
                    layers[self.dlg.comboriver.currentIndex()].source()

            road_file = self.dlg.comboroad.currentText()\
                if os.path.isfile(self.dlg.comboroad.currentText()) else\
                    layers[self.dlg.comboroad.currentIndex()].source()
                    
            region_file = self.dlg.comboregion.currentText()\
                if os.path.isfile(self.dlg.comboregion.currentText()) else\
                    layers[self.dlg.comboregion.currentIndex()].source()
                    
            dis = self.dlg.disEdit.text()
            dis = None if dis == '' else eval(dis)
            
            outdis = self.dlg.disEdit2.text()
            outdis = None if outdis == '' else eval(outdis)
            
            # river_file = None if river_file == '' else river_file
            # region_file = None if region_file == '' else region_file
            if self.dlg.checkBox.isChecked():  
                has_river = True
            else:
                has_river = False
                
            outdir = self.dlg.outdirEdit.text()
            if os.path.isdir(outdir) ==False:
                self.iface.messageBar().pushMessage("出错", "输出路径格式错误",
                                                level=Qgis.Critical, duration=3)                
            pipes = gpd.read_file(pipe_file,encoding='gbk')
            river = gpd.read_file(river_file,encoding='gbk')
            road = gpd.read_file(road_file,encoding='gbk') 
            region = gpd.read_file(region_file,encoding='gbk') if region_file is not None else None
            
            nodes,pipes = read_resample(pipes,river,dis)
            Polygons,riverpoly,riverpoints = create_subcatch(nodes,pipes,road,river,
                                                 region,has_river)
            nodes = update_area(nodes,Polygons)        
            nodes,pipes = create_out(nodes,pipes,river,outdis)
            X = formulate(nodes,pipes)
            X,outfalls = break_pipes(X)
            X = break_cycle(X, outfalls)
            nodes,pipes = export_net(X)            
            Polygons,Area = merge_outfall_area(X,Polygons)                        
                    
            Area.to_file(os.path.join(outdir,'subsystem.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'subsystem.shp'),'subsystem',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'subsystem')    

            riverpoly.to_file(os.path.join(outdir,'riverpoly.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'riverpoly.shp'),'riverpoly',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'riverpoly')    
                
            Polygons.to_file(os.path.join(outdir,'subcatch.shp'))
            vlayer = QgsVectorLayer(os.path.join(outdir,'subcatch.shp'),'subcatch',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'subcatch')
                
            pipes.to_file(os.path.join(outdir,'pipes.shp'))            
            vlayer = QgsVectorLayer(os.path.join(outdir,'pipes.shp'),'pipes',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'pipes')                
                
            nodes.to_file(os.path.join(outdir,'nodes.shp'))            
            vlayer = QgsVectorLayer(os.path.join(outdir,'nodes.shp'),'nodes',"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%'nodes')   
                          
            # nx.write_gpickle(X,outdir)
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            self.iface.messageBar().pushMessage("成功", "平面布局设计",
                                                level=Qgis.Success, duration=3)
    
    

    def Hydraul(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.create_hydraul.first_start == True:
        # self.create_hydraul.first_start = False
        self.dlg = RSHydraulDialog()
        self.dlg.inputButton.clicked.connect(self.select_node)
        self.dlg.inputButton_2.clicked.connect(self.select_nodefield)
        self.dlg.inputButton2.clicked.connect(self.select_line)
        self.dlg.inputButton2_2.clicked.connect(self.select_linefield)
        self.dlg.inputButton3.clicked.connect(self.select_config)
        self.dlg.inputButton4.clicked.connect(self.select_dem)
        self.dlg.inputButton4_2.clicked.connect(self.select_demfield)
        self.dlg.inputButton5.clicked.connect(self.select_region)
        self.dlg.inputButton5_2.clicked.connect(self.select_regionfield)
        self.dlg.inputButton6.clicked.connect(self.select_river)
        self.dlg.inputButton6_2.clicked.connect(self.select_riverfield)
        self.dlg.outputButton.clicked.connect(self.output_dir)         
        self.dlg.comboriver.currentTextChanged.connect(self.river_changed)
        self.dlg.combodem.currentTextChanged.connect(self.dem_changed)
        self.dlg.combonode.currentTextChanged.connect(self.node_changed)
        self.dlg.comboline.currentTextChanged.connect(self.line_changed)
        self.dlg.comboregion.currentTextChanged.connect(self.region_changed)
        self.dlg.checkBox.stateChanged.connect(self.check_changed)
            

        layers = list(QgsProject.instance().mapLayers().values())
        self.layers = layers
        layer_names = [l.name() for l in layers]
        self.dlg.comboline.clear()
        self.dlg.combonode.clear()
        self.dlg.combodem.clear()
        self.dlg.comboregion.clear()
        self.dlg.comboriver.clear()

        self.dlg.comboline.addItems(layer_names)
        self.dlg.combonode.addItems(layer_names)
        self.dlg.combodem.addItems(layer_names)
        self.dlg.comboregion.addItems(layer_names)
        self.dlg.comboriver.addItems(layer_names)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pipe_file = self.dlg.comboline.currentText()\
                if os.path.isfile(self.dlg.comboline.currentText()) else\
                    layers[self.dlg.comboline.currentIndex()].source()    
            config_text = self.dlg.configEdit.text()

            dem_file = self.dlg.combodem.currentText()\
                if os.path.isfile(self.dlg.combodem.currentText()) else\
                    layers[self.dlg.combodem.currentIndex()].source()                
            
            subcatch_file = self.dlg.comboregion.currentText()\
                if os.path.isfile(self.dlg.comboregion.currentText()) else\
                    layers[self.dlg.comboregion.currentIndex()].source()   
                    
            outdir = self.dlg.outdirEdit.text()
            if os.path.isdir(outdir) == False:
                self.iface.messageBar().pushMessage("出错", "输出路径格式错误",
                                                    level=Qgis.Critical, duration=3)                         
            config = configurate(config_text)
            if dem_file.endswith('.tif') == False:
                dem_file = DEMGenerate(dem_file,self.demfield)            
            
            if self.dlg.checkBox.isChecked():
                river_file = self.dlg.comboriver.currentText()\
                    if os.path.isfile(self.dlg.comboriver.currentText()) else\
                        layers[self.dlg.comboriver.currentIndex()].source()   
                pipes = gpd.read_file(pipe_file)
                river = gpd.read_file(river_file)
                resam,dis,outd = self.riverfield
                if resam:
                    nodes,pipes = read_resample(pipes, river, dis)
                else:
                    nodes,pipes = read_pipes(pipes, river)
                nodes,pipes = create_out(nodes,pipes,river,outd)
                
                subcatch = gpd.read_file(subcatch_file)
                subcatch = find_node(nodes,subcatch)
                nodes = update_area(nodes,subcatch)
                X = formulate(nodes,pipes)
                
                
            else:
                node_file = self.dlg.combonode.currentText()\
                    if os.path.isfile(self.dlg.combonode.currentText()) else\
                        layers[self.dlg.combonode.currentIndex()].source()
                nodes = gpd.read_file(node_file)
                pipes = gpd.read_file(pipe_file)
                X = formulate(nodes,pipes,self.nodefield,self.linefield)
                subcatch = gpd.read_file(subcatch_file)
                sid,node,area = self.regionfield
                subcatch['id'] = subcatch[sid]
                subcatch['node'] = subcatch[node]
                subcatch['area'] = subcatch[area] if area != 'geometry.area' else subcatch['geometry'].area
                                
                
            X = check_field(X)

            X = get_elevation(X,dem_file)
            DX = update_graph(X,config)
                
            nodes,pipes = export_net(DX)
            
            table = export_hydraulic_table(DX)
            table.to_excel(os.path.join(outdir,'水力计算表.xlsx'),encoding='gbk')
            quanti = eval_quanti(pipes,'diameter')
            quanti.to_excel(os.path.join(outdir,'工程量统计.xlsx'),encoding='gbk')

            create_model(nodes,pipes,subcatch,os.path.join(outdir,'model.inp'))
            
            
            if self.dlg.checkBox.isChecked():
                subcatch,Area = merge_outfall_area(X,subcatch) 
                       
                outregiondir = os.path.join(outdir,'subsystem.shp')
                Area.to_file(outregiondir)
                vlayer = QgsVectorLayer(outregiondir,'subsystem',"ogr")
                if vlayer.isValid():
                    QgsProject.instance().addMapLayer(vlayer)
                else:
                    print("%s图层加载失败！"%'subsystem')        
                    
                outpolydir = os.path.join(outdir,'subcatch.shp')
                subcatch.to_file(outpolydir)
                vlayer = QgsVectorLayer(outpolydir,'subcatch',"ogr")
                if vlayer.isValid():
                    QgsProject.instance().addMapLayer(vlayer)
                else:
                    print("%s图层加载失败！"%'subcatch')                
            
            outpipedir = os.path.join(outdir,'pipes.shp')
            pipes.to_file(outpipedir)            
            layerName = os.path.split(outpipedir)[-1].split('.')[0]
            vlayer = QgsVectorLayer(outpipedir,layerName,"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%layerName)    

            outnodedir = os.path.join(outdir,'nodes.shp')
            nodes.to_file(outnodedir)            
            layerName = os.path.split(outnodedir)[-1].split('.')[0]
            vlayer = QgsVectorLayer(outnodedir,layerName,"ogr")
            if vlayer.isValid():
                QgsProject.instance().addMapLayer(vlayer)
            else:
                print("%s图层加载失败！"%layerName)                   
            # nx.write_gpickle(X,outdir)
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            self.iface.messageBar().pushMessage("成功", "水力设计",
                                                level=Qgis.Success, duration=3)                

    def setProgress(self,value):
        self.dlg3.pgbar.setValue(value)
         
    def setProgress2(self,value):
        self.dlg3.pgbar2.setValue(value)        
        
    def simu(self,file,ts,idx):
        self.dlg3.label_2.setText(ts)
        sign = 'progress_update%s'%(idx)
        ori_path = getcwd()
        inp_path,file = os.path.split(file)
        chdir(inp_path)
        sim =  Simulation(file)
        chdir(ori_path)
        for st in sim:
            sim.step_advance(300)
            perc = int(sim.percent_complete*100)
            getattr(so,sign).emit(perc)         
        sim.close()     
        getattr(so,sign).emit(100)
        self.simulation_finished[idx-1] = True
        

        
    def valueChanged(self):
        if self.simulation_finished[0]:
            if self.dlg.checkBox.isChecked():
                inp_file = self.dlg.lineEdit.text()
                ts2 = self.dlg.comboBox_2.currentText()
                kind2 = self.dlg.typeBox_2.currentText()
                runoff_co2 = eval(self.dlg.coeEdit_2.text())
                dura = self.dlg.duraEdit_2.text()
                file2 = get_simulate_file(self.inp,inp_file,ts2,kind2,runoff_co2,dura,
                                          self.rainfield[ts2])
                self.files.append(file2)                
                
                self.worker = Thread(target=self.simu,args=(file2,ts2,2))
                self.worker.start()
            else:
                self.dlg3.pushButton.setText('完成')
                self.dlg3.label_2.setText('已完成模拟')
           
    def valueChanged2(self):
        if set(self.simulation_finished) == {True}:
            self.dlg3.pushButton.setText('完成')       
            self.dlg3.label_2.setText('已完成模拟')
            
    def simu_changed(self):
        self.dlg3.close()
        if set(self.simulation_finished) == {True}:
            ress = []
            for file in self.files:
                rpt_file = file.replace('.inp','.rpt')
                res = eval_rpt(rpt_file,self.inp)
                ress.append(res)
            res = gpd.pd.concat(ress,axis=0)         
            outcsvdir = self.dlg.outdirEdit.text()
            res.to_csv(outcsvdir,encoding='gb2312')        
            self.iface.messageBar().pushMessage("成功", "模拟评估降雨序列",
                                                level=Qgis.Success, duration=3)
        else:
            self.worker.join(1)

            
            
    def Simulate(self):
        # if self.eval_simulate.first_start == True:
        #     self.eval_simulate.first_start = False
        self.dlg = RSSimulateDialog()
        self.dlg.inputButton.clicked.connect(self.select_inp)
        self.dlg.lineEdit.textChanged.connect(self.inp_changed)
        self.dlg.rainButton.clicked.connect(self.set_rainfall)
        self.dlg.rainButton_2.clicked.connect(self.set_rainfall2)
        self.dlg.comboBox.currentTextChanged.connect(self.rain_changed)
        self.dlg.comboBox_2.currentTextChanged.connect(self.rain_changed)
        self.dlg.outputButton.clicked.connect(self.output_csv)
        self.dlg.checkBox.stateChanged.connect(self.enable_rain2)
        
        self.dlg2 = RSRainDialog()
        self.dlg2.comboBox.currentTextChanged.connect(self.type_changed)
        self.dlg2.fileButton.clicked.connect(self.select_rain)
        self.dlg2.chicagoButton.clicked.connect(self.insert_chicago)
            
        self.dlg.comboBox.clear()
        self.dlg.comboBox_2.clear()
        
        self.dlg3 = RSProcessDialog()
        self.dlg3.pgbar.setMinimum(0)
        self.dlg3.pgbar.setMaximum(100)
        self.dlg3.pgbar.setValue(0)
        self.dlg3.pgbar2.setMinimum(0)
        self.dlg3.pgbar2.setMaximum(100)
        self.dlg3.pgbar2.setValue(0)        
        self.dlg3.pgbar.valueChanged.connect(self.valueChanged)
        self.dlg3.pgbar2.valueChanged.connect(self.valueChanged2)
        self.dlg3.pgbar2.setEnabled(False)     
        self.dlg3.pushButton.clicked.connect(self.simu_changed)
        self.dlg3.pushButton.setText('取消')
        
        so.progress_update1.connect(self.setProgress)
        so.progress_update2.connect(self.setProgress2)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            inp_file = self.dlg.lineEdit.text()
            ts = self.dlg.comboBox.currentText()
            kind = self.dlg.typeBox.currentText()
            runoff_co = eval(self.dlg.coeEdit.text())
            dura = self.dlg.duraEdit.text()

            self.dlg3.show()            
            file = get_simulate_file(self.inp,inp_file,ts,kind,runoff_co,dura,
                                     self.rainfield[ts])
            self.files = [file]
            self.simulation_finished = [False]
            if self.dlg.checkBox.isChecked():
                self.dlg3.pgbar2.setEnabled(True)
                self.simulation_finished.append(False)
            self.worker = Thread(target=self.simu,args=(file,ts,1))
            self.worker.start()   
